"use strict";(self.webpackChunkstarvie=self.webpackChunkstarvie||[]).push([[290],{6290:(t,e,n)=>{n.r(e),n.d(e,{default:()=>f});var a=n(6882),r=n(8537),i=n(7210),o=n(7294),s=n(9477),l=(n(1766),n(6357));const d={uniforms:{iTime:{type:"f",value:0},iResolution:{type:"v2",value:{x:0,y:0}}},vertexShader:n(3083),fragmentShader:l};var c=n(8964);a.L.preload("starviee.glb");var m=function(t){var e=t.client,n=(0,a.L)("starviee.glb"),l=n.nodes,m=n.materials,f=(0,o.useRef)(),u=(0,o.useRef)(),v=(0,o.useRef)(),p=(0,i.Ky)(),g=p.size,x=p.viewport,h=new s.Object3D,y=function(t,e,n,a){t.forEach((function(t,r){h.position.set(t.p.x*x.width/2,t.p.y*x.height/2,0),h.rotation.set(e.x+t.r.x,e.y+t.r.y,e.z+t.r.z),h.scale.set(n.x,n.y,n.z),h.updateMatrix(),a.current.setMatrixAt(r,h.matrix)})),a.current.instanceMatrix.needsUpdate=!0};return(0,o.useEffect)((function(){return f.current.material.uniforms.iResolution.value={x:g.width,y:g.height},e.on("data",(function(t){f.current.material.uniforms.iTime.value=t.t,y(t.sps,{x:Math.PI/2,y:Math.PI,z:0},{x:.1,y:.1,z:.1},u),y(t.ats,{x:0,y:0,z:0},{x:1,y:1,z:1},v)})),function(){return e.close()}}),[]),(0,i.xQ)((function(t){var n=t.mouse,a={m:{x:n.x,y:n.y}};e.send(a)})),o.createElement(o.Fragment,null,o.createElement("ambientLight",null),o.createElement("pointLight",{position:[5,5,5]}),o.createElement("mesh",{ref:f,position:[0,0,-1]},o.createElement("planeBufferGeometry",{args:[g.width,g.height]}),o.createElement("shaderMaterial",{attach:"material",args:[d]})),o.createElement("instancedMesh",{ref:u,args:[l.Spitfire.geometry,m.Texture,c.L]}),o.createElement("instancedMesh",{ref:v,args:[l.Asteroid.geometry,m["Concrete 3"],c.w]}),o.createElement(r.j,null))};function f(t){var e=t.client;return o.createElement(i.Xz,null,o.createElement(m,{client:e}))}},6357:t=>{t.exports="uniform vec3 iResolution;\nuniform float iTime;\n\n// Star Nest by Pablo Roman Andrioli\n\n#define iterations 10\n#define formuparam 0.53\n\n#define volsteps 8\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t//get coords and direction\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.y *= iResolution.y / iResolution.x;\n\tvec3 dir = vec3(uv * zoom, 1.);\n\tfloat time = iTime * speed + .25;\n\n\t//mouse rotation\n\tfloat a1 = .5;\n\tfloat a2 = .8;\n\tmat2 rot1 = mat2(cos(a1), sin(a1), -sin(a1), cos(a1));\n\tmat2 rot2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));\n\tdir.xz *= rot1;\n\tdir.xy *= rot2;\n\tvec3 from = vec3(1., .5, 0.5);\n\tfrom += vec3(0., time, -2.);\n\tfrom.xz *= rot1;\n\tfrom.xy *= rot2;\n\n\t//volumetric rendering\n\tfloat s = 0.1, fade = 1.;\n\tvec3 v = vec3(0.);\n\tfor(int r = 0; r < volsteps; r++) {\n\t\tvec3 p = from + s * dir * .5;\n\t\tp = abs(vec3(tile) - mod(p, vec3(tile * 2.))); // tiling fold\n\t\tfloat pa, a = pa = 0.;\n\t\tfor(int i = 0; i < iterations; i++) {\n\t\t\tp = abs(p) / dot(p, p) - formuparam; // the magic formula\n\t\t\ta += abs(length(p) - pa); // absolute sum of average change\n\t\t\tpa = length(p);\n\t\t}\n\t\tfloat dm = max(0., darkmatter - a * a * .001); //dark matter\n\t\ta *= a * a; // add contrast\n\t\tif(r > 6)\n\t\t\tfade *= 1. - dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv += fade;\n\t\tv += vec3(s, s * s, s * s * s * s) * a * brightness * fade; // coloring based on distance\n\t\tfade *= distfading; // distance fading\n\t\ts += stepsize;\n\t}\n\tv = mix(vec3(length(v)), v, saturation); //color adjust\n\tfragColor = vec4(v * .01, 1.);\n}\n\nvoid main() {\n\tmainImage(gl_FragColor, gl_FragCoord.xy);\n}"},3083:t=>{t.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}"}}]);